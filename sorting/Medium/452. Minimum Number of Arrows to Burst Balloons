        sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[1] < b[1];  // Sort by end time
        });

        int arrows = 1;  // At least one arrow needed
        int lastEnd = points[0][1];  // The end position of the first balloon

        // Step 2: Traverse through balloons
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > lastEnd) {  // If the balloon starts after the last end, need a new arrow
                arrows++;  // New arrow needed
                lastEnd = points[i][1];  // Update lastEnd to the new balloon's end
            }
        }

        return arrows;
    }
